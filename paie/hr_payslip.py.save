# -*- coding: utf-8 -*-
from dateutil import relativedelta
import locale
from openerp import exceptions
from datetime import datetime, timedelta
import time
from openerp import netsvc
from openerp.tools.translate import _
from openerp import fields, models, api, tools, workflow
from openerp.tools import (
    DEFAULT_SERVER_DATE_FORMAT,
    )
from openerp.tools import float_compare, float_is_zero
from lxml import etree
from openerp.osv.orm import setup_modifiers
import re


class HrPayslip(models.Model):
    _inherit = 'hr.payslip'

    def nbr_jr_trav(self):
        nbr=0
        for l in self.worked_days_line_ids:
            nbr=nbr+l.number_of_days
        return locale.format("%.2f", nbr, grouping=True)

    nbr_jours = fields.Float(compute='get_nbr_jr_conges_payes')
    nbr_jr_conges_payes=fields.Float(compute='nbr_jr_conges_payes')
    sal_journalier = fields.Float(compute='get_salaire_journalier')

    def _get_default_journal(self):
        journal=self.env['account.journal'].search([['code','=','JPaie']])
        return journal or False

    def get_default_period(self):
        today = datetime.today().date()
        period =today.strftime("%m")+'/'+today.strftime("%Y")
        periods = self.env['account.period'].search([['name','=',period]])
        return periods or False

    cumulregularise = fields.Float('Cumul imposable régularisé')
    arrprec = fields.Float('Arrondi du mois précédent')
    regul = fields.Boolean('Appliquer régularisations')
    nbr_mois = fields.Integer('Nombre de mois')
    brutCNSSma=fields.Float('Cumul Brut Imposable')
    ded_cachrges_famil=fields.Float('Cumul Déd.Charges Familiales')
    cumul_FPRO=fields.Float('Cumul Frais Professionnels')
    cumul_IRPP=fields.Float('Cumul IR')
    cumul_epargne=fields.Float('Cumul Epargne Retraite')
    cumul_deductions_log=fields.Float('Cumul déductions logement')
    cumul_interet_habitat=fields.Float('Cumul Intérêt Habitat')
    cumul_jours=fields.Float('Cumul Jours Travaillés')
    cumul_Net_imposable=fields.Float('Cumul Net Imposable')
    cumul_Charges_salariales=fields.Float('Cumul Charges Salariales')
    journal_id= fields.Many2one('account.journal', 'Salary Journal',states={'draft': [('readonly', False)]}, readonly=True, required=True, default=_get_default_journal)
    cumul_imposable=fields.Float(compute='somme_cumul_imposable',store=True)
    arr_prec = fields.Float(compute='get_arrondi_prec',store=True)
    nbr_payslip=fields.Float(compute='somme_cumul_imposable',store=True)
    somme_impot=fields.Float(compute='somme_cumul_imposable',store=True)
    somme_fpro=fields.Float(compute='somme_cumul_imposable',store=True)
    fpro_reste=fields.Float(compute='get_fpro_reste',store=True)
    somme_rg_fpro=fields.Float(compute='somme_cumul_imposable',store=True)
    comptabilise = fields.Boolean('Comptabilsé', default=False)
    periode = fields.Many2one('account.period','Période',default=get_default_period )
    duree_anciennete = fields.Integer('Durée',compute='get_duree',store=True)
    events = fields.One2many('hr.event','event_id')
    rubriques_ids = fields.One2many('hr.payslip.primes','payslip_id')
    jours_acquis=fields.Float('Jours acquis',compute='calculer_nbr_jr_acquis',store=True)
    solde_conge=fields.Float('Solde congés',compute='sum_jrs_acquis',store=True)
    readonly= fields.Boolean('Mode lecture seule',compute='get_readonly')
    etat_du_lot= fields.Boolean('Etat du lot',compute='get_state')
    state=fields.Selection([
            ('draft', 'Draft'),
            ('verify', 'Waiting'),
            ('done', 'Validé'),
            ('cancel', 'Rejected'),], 'Status', select=True, readonly=True, copy=False,)

    @api.multi
    def get_name_of_report(self):
        name= self.employee_id.matricule+'_'+self.employee_id.nom+'_'+self.employee_id.prenom+'_'+self.periode.name
        if self.state=='draft':
            name=name+''+'_Brouillon'
        return name

    def onchange_contract_id(self, cr, uid, ids, date_from, date_to, employee_id=False, contract_id=False, context=None):
        contract_obj = self.pool.get('hr.contract')
        #res = super(HrPayslip, self).onchange_contract_id(cr, uid, ids, date_from=date_from, date_to=date_to, employee_id=employee_id, contract_id=contract_id, context=context)
        return True

    def get_state(self):
        payslip_state=self.state
        value=True
        batch_state=self.payslip_run_id and self.payslip_run_id.state or False
        if batch_state :
            if batch_state=='close':
                if payslip_state=='done' :
                    value=False
                else :
                    value=True
        self.etat_du_lot=value

    def get_readonly(self):
        payslip_state=self.state
        value=False
        if payslip_state=='done' :
            value=True
        else :
            value=False
        self.readonly=value

    def draft_payslip(self, cr, uid, ids,*args):
        if not len(ids):
            return False
        self.write(cr, uid, ids, {'state': 'draft'})
        wf_service = netsvc.LocalService("workflow")
        for p_id in ids:
            # Deleting the existing instance of workflow for PO
            wf_service.trg_delete(uid, 'hr.payslip', p_id, cr)
            wf_service.trg_create(uid, 'hr.payslip', p_id, cr)
        return True

    @api.v7
    def fields_view_get(self, cr, user, view_id=None, view_type='form', context=None, toolbar=False, submenu=False):
        if context is None:
            context = {}
        res = super(HrPayslip, self).fields_view_get(cr, user, view_id, view_type, context, toolbar, submenu)
        doc = etree.XML(res['arch'])
        if view_type == 'form':
            for field in res['fields']:
                if field in ('contract_id') :
                    continue
                nodes = doc.xpath("//field[@name='%s']"%field)
                for node in nodes:
                    if not node.get('attrs') :
                        attrs="{ 'readonly':[('readonly','=',True)] }"
                        node.set('attrs',attrs )
                    else :
                        attrs=node.get('attrs')
                        if attrs.find('readonly')==-1:
                            sc=re.sub('[{}]','',attrs)
                            attrs="{"+sc+",'readonly':[ ('readonly','=',True) ] } "
                            node.set('attrs',attrs)
                        else:
                            attrs=attrs.replace('[',"[ '|',").replace("]",",('readonly','=',True)]")
                            node.set('attrs',attrs)
                    setup_modifiers(node, res['fields'][field])
        res['arch'] = etree.tostring(doc)
        return res

    @api.one
    @api.depends('contract_id','periode')
    def get_nbr_jr_conges_payes(self):
        nbr=0
        emp_holidays = self.env['hr.holidays'].search([['employee_id','=',self.employee_id.id]])
        for ho in emp_holidays:
            nbr=+ho.number_of_days_temp
        self.nbr_jours = nbr



    def nbr_jr_conge_pay(self):
        nbr=0
        emp_holidays = self.env['hr.holidays'].search([['employee_id','=',self.employee_id.id]])
        for ho in emp_holidays:
            nbr=+ho.number_of_days_temp
        return locale.format("%.2f", nbr, grouping=True)
    @api.one
    @api.depends('periode','employee_id','contract_id')
    def get_fpro_reste(self):
        fpro_reste=0
        payslip=self.search([['employee_id','=',self.employee_id.id],['date_from','=',datetime.strptime(self.date_from, DEFAULT_SERVER_DATE_FORMAT)-relativedelta.relativedelta(months=1)]])
        if payslip:
            for rule in payslip[0].details_by_salary_rule_category:
                if rule.code=='fpro_reste':
                    fpro_reste=rule.total
        self.fpro_reste=fpro_reste

    @api.one
    @api.depends('periode', 'employee_id')
    def somme_cumul_imposable(self):
        payslips=self.search([['employee_id', '=', self.employee_id.id]])
        pay_year=[]
        for p in payslips:
            if datetime.strptime(p.date_from, DEFAULT_SERVER_DATE_FORMAT).year == datetime.strptime(self.date_from, DEFAULT_SERVER_DATE_FORMAT).year:
                pay_year.append(p)
        somme_cumul_imposable=0
        somme_ir_payes=0
        somme_impot=0
        somme_fpro=0
        somme_rg_fpro=0
        n = 0

        for i in pay_year:
            n+=1
            for k in i.details_by_salary_rule_category:
                if k.code == 'C_IMP':

                    somme_cumul_imposable += k.total
                elif k.code=='IRPP':
                    somme_ir_payes+=k.total
                elif k.code in ['T1' , 'T2','T3','T4','T5']:
                    somme_impot+=k.total
                elif k.code=='FPRO':
                    somme_fpro+=k.total
                elif k.code=='RG_FPRO':
                    somme_rg_fpro+=k.total
        self.cumul_imposable = somme_cumul_imposable
        self.nbr_payslip=n
        self.somme_impot=somme_ir_payes
        self.somme_fpro=somme_fpro
        self.somme_rg_fpro=somme_rg_fpro

    def process_sheet(self):
        return self.write({'paid': True, 'state': 'done'})

    @api.one
    @api.depends('worked_days_line_ids','jours_acquis')
    def sum_jrs_acquis(self):
        holidays_pool=self.env['hr.holidays']
        if not self.employee_id:
            self.solde_conge=0
        else:
            holidays=self.env['hr.holidays'].search([['employee_id','=',self.employee_id.id]])
            if holidays:
                self.solde_conge=holidays[0].current_remaining_leaves
            else:
                self.solde_conge=0
        self.solde_conge+=self.jours_acquis
        return self.solde_conge

    @api.one
    @api.depends('worked_days_line_ids','events')
    def calculer_nbr_jr_acquis(self):
        if not self.employee_id:
            self.jours_acquis=0
        else:
            if self.contract_id:
                self.jours_acquis=self.contract_id.nbr_jr_conge
                dt=0
                events=self.get_events_impact_conge()
                if events:
                    for e in events:
                        if e.categorie_type_event=='absMaladie' and e.status=='valide':
                            dt+=e.compute_duration()
                    self.jours_acquis-=dt/26
            else:
                self.jours_acquis=0
        return self.jours_acquis

    @api.multi
    @api.onchange('periode')
    def onchange_period(self):
        if self.periode:
            self.date_from=self.periode.date_start
            self.date_to=self.periode.date_stop
        else:
            raise exceptions.Warning('veuillez choisir une période valide')

    @api.one
    @api.depends('date_from')
    def get_duree(self):
        #self.ensure_one()
        if self.date_from and self.date_to:
            contrat = self.env['hr.contract'].search([['employee_id', '=', self.employee_id.id], ['date_start', '<=', self.date_from], ['date_end', '>=', self.date_from]])
            if len(contrat) == 1:
                self.contract_id = contrat
                if contrat.date_end < self.date_to:
                    self.date_to = contrat.date_end
                    exceptions.ValidationError('la date fin choisi')
                a= (datetime.strptime(self.date_from, DEFAULT_SERVER_DATE_FORMAT) - datetime.strptime( self.contract_id.date_anciennetee, DEFAULT_SERVER_DATE_FORMAT)).days/365
                self.duree_anciennete=a
                return self.duree_anciennete
            elif len(contrat) == 0:
                contrat = self.env['hr.contract'].search([['employee_id', '=', self.employee_id.id], ['date_start', '<=',self.date_to], ['date_end', '>=', self.date_from]])
                if len(contrat) == 1:
                    self.contract_id = contrat
                    if contrat.date_start > self.date_from:
                        self.date_from = contrat.date_start
                        exceptions.ValidationError('la date debut choisi')
                else:
                    self.contract_id = self.env['hr.contract']
            else:
                raise exceptions.Warning('err')

    def onchange_employee_id(self, cr, uid, ids, date_from, date_to, employee_id=False, contract_id=False, context=None):
        empolyee_obj = self.pool.get('hr.employee')
        contract_obj = self.pool.get('hr.contract')
        worked_days_obj = self.pool.get('hr.payslip.worked_days')
        primes_obj=self.pool.get('hr.payslip.primes')
        input_obj = self.pool.get('hr.payslip.input')
        if context is None:
            context = {}
        #delete old worked days lines
        old_worked_days_ids = ids and worked_days_obj.search(cr, uid, [('payslip_id', '=', ids[0])], context=context) or False
        if old_worked_days_ids:
            worked_days_obj.unlink(cr, uid, old_worked_days_ids, context=context)
        #delete old input lines
        old_input_ids = ids and input_obj.search(cr, uid, [('payslip_id', '=', ids[0])], context=context) or False
        if old_input_ids:
            input_obj.unlnink(cr, uid, old_input_ids, context=context)

        #delete old input lines
        primes = ids and primes_obj.search(cr, uid, [('payslip_id', '=', ids[0])], context=context) or False
        if old_input_ids:
            primes_obj.unlnink(cr, uid, primes, context=context)
        #defaults
        res = {'value':{
                      'line_ids':[],
                      'input_line_ids': [],
                      'worked_days_line_ids': [],
                      'rubriques_ids':[],
                      'events':[],
                      #'details_by_salary_head':[], TODO put me back
                      'name':'',
                      'contract_id': False,
                      'struct_id': False,
                      }
            }
        if (not employee_id) or (not date_from) or (not date_to):
            return res
        ttyme = datetime.fromtimestamp(time.mktime(time.strptime(date_from, "%Y-%m-%d")))
        employee_id = empolyee_obj.browse(cr, uid, employee_id, context=context)
        res['value'].update({
                    'name': _('Bulletin %s %s') % (employee_id.name, tools.ustr(ttyme.strftime('%m/%Y'))),
                    'company_id': employee_id.company_id.id
        })

        if not context.get('contract', False):
            #fill with the first contract of the employee
            contract_ids = self.get_contract(cr, uid, employee_id, date_from, date_to, context=context)
        else:
            if contract_id:
                #set the list of contract for which the input have to be filled
                contract_ids = [contract_id]
                contract=self.pool.get('hr.contract').browse(cr, uid, contract_ids[0], context=context)

            else:
                #if we don't give the contract, then the input to fill should be for all current contracts of the employee
                contract_ids = self.get_contract(cr, uid, employee_id, date_from, date_to, context=context)

        if not contract_ids:
            return res
        contract_record = contract_obj.browse(cr, uid, contract_ids[0], context=context)
        res['value'].update({
                    'contract_id': contract_record and contract_record.id or False
        })
        struct_record = contract_record and contract_record.struct_id or False
        if not struct_record:
            return res
        res['value'].update({
                    'struct_id': struct_record.id,
        })
        #computation of the salary input
        worked_days_line_ids = self.get_worked_day_lines(cr, uid, contract_ids, date_from, date_to, context=context)
        input_line_ids = self.get_inputs(cr, uid, contract_ids, date_from, date_to, context=context)
        res['value'].update({
                    'worked_days_line_ids': worked_days_line_ids,
                    'input_line_ids': input_line_ids,
        })

        events=[]
        record=employee_id.event_ids
        for e in record:
            '''if e.date_debut>= date_from or e.date_fin >= date_to:
                record=record - e'''

            if e.date_debut>= contract_record.date_end or e.date_fin >= contract_record.date_end:
                record=record - e

        res['value'].update({'events':record})
        return res

    @api.multi
    def compute_sheet(self):
        for i in self._ids:
            pay=self.env['hr.payslip'].browse(i)
            pay.cumul_annuel()
            x=pay.add_event_in_rules()
            super(HrPayslip, pay).compute_sheet()
            if x:
                for e in x:
                    self.env['hr.payroll.structure'].browse([pay.struct_id.id]).write({'rule_ids': [(3, e, False)]})
                    #self.env['hr.salary.rule'].browse([prime]).unlink()'''
        return True

    @api.one
    @api.depends('periode', 'employee_id')
    def get_arrondi_prec(self):
        arr_janvier=[{'matricule':'1','arrondi':0.00},{'matricule':'2','arrondi':0.33},{'matricule':'5','arrondi':0.58},
                     {'matricule':'6','arrondi':0.24},{'matricule':'8','arrondi':0.35},{'matricule':'9','arrondi':0.28},
                     {'matricule':'17','arrondi':0.73},{'matricule':'18','arrondi':0.92},{'matricule':'22','arrondi':0.05},
                     {'matricule':'30','arrondi':0.43},{'matricule':'34','arrondi':0.39},{'matricule':'37','arrondi':0.78},
                     {'matricule':'39','arrondi':0.20},{'matricule':'49','arrondi':0.57},{'matricule':'55','arrondi':0.03},
                     {'matricule':'57','arrondi':0.71},{'matricule':'60','arrondi':0.87},{'matricule':'66','arrondi':0.19},
                     {'matricule':'68','arrondi':0.40},{'matricule':'69','arrondi':0.71},{'matricule':'70','arrondi':0.62},
                     {'matricule':'71','arrondi':0.71},{'matricule':'73','arrondi':0.10},{'matricule':'75','arrondi':0.20},
                     {'matricule':'76','arrondi':0.23},{'matricule':'79','arrondi':0.16},{'matricule':'80','arrondi':0.67},
                     {'matricule':'85','arrondi':0.79},{'matricule':'89','arrondi':0.50},{'matricule':'91','arrondi':0.73},
                     {'matricule':'93','arrondi':0.46},{'matricule':'94','arrondi':0.75},{'matricule':'95','arrondi':0.95},
                     {'matricule':'96','arrondi':0.47},{'matricule':'97','arrondi':0.45},{'matricule':'98','arrondi':0.47},
                     {'matricule':'100','arrondi':0.26},{'matricule':'102','arrondi':0.82},{'matricule':'104','arrondi':0.44},
                     {'matricule':'106','arrondi':0.22},{'matricule':'108','arrondi':0.06},{'matricule':'109','arrondi':0.61},
                     {'matricule':'110','arrondi':0.01},{'matricule':'111','arrondi':0.92},{'matricule':'112','arrondi':0.73},
                     {'matricule':'113','arrondi':0.74},{'matricule':'114','arrondi':0.58},{'matricule':'115','arrondi':0.77},
                     {'matricule':'117','arrondi':0.23},{'matricule':'118','arrondi':0.13},{'matricule':'119','arrondi':0.26},
                     {'matricule':'121','arrondi':0.40},{'matricule':'122','arrondi':0.63},{'matricule':'123','arrondi':0.77},
                     {'matricule':'126','arrondi':0.94},{'matricule':'127','arrondi':0.59},{'matricule':'128','arrondi':0.03},
                     {'matricule':'130','arrondi':0.02},{'matricule':'131','arrondi':0.14},{'matricule':'132','arrondi':0.50},
                     {'matricule':'133','arrondi':0.16},{'matricule':'137','arrondi':0.25},{'matricule':'142','arrondi':0.77},
                     {'matricule':'143','arrondi':0.01},{'matricule':'144','arrondi':0.12},{'matricule':'146','arrondi':0.89}
                     ]
        self.arr_prec=0.00
        if self.periode.name=='01/2016':
            print 'ooo'
            for arr in arr_janvier:
                if self.employee_id.matricule==arr['matricule']:
                    self.arr_prec=arr['arrondi']

        else:
            bp_precedent=self.search([['employee_id','=',self.employee_id.id]])
            if bp_precedent:
                for b in bp_precedent:
                    if datetime.strptime(b.date_from, DEFAULT_SERVER_DATE_FORMAT).month==datetime.strptime(self.date_from, DEFAULT_SERVER_DATE_FORMAT).month-1:
                        for r in b.details_by_salary_rule_category:
                            if r.code=='arrondiEnCours':
                                self.arr_prec=r.total
                                break
                    break

    @api.multi
    def hr_verify_sheet(self):
        res = super(HrPayslip, self).hr_verify_sheet()
        events=self.env['hr.salary.rule'].search([['code','=',str(self.id)]])
        for evt in events:
            evt.unlink()
        self.check_payroll()
        return res

    @api.multi
    def cumul_annuel(self):
        payslips=self.env['hr.payslip'].search([['employee_id','=',self.employee_id.id]])
        somme_net=0
        for i in payslips:
            for k in i.line_ids:
                if k.code=='NET':
                    somme_net=somme_net+k.total

    @api.multi
    def regul_ir(self):
        payslips=self.env['hr.payslip'].search([['employee_id','=',self.employee_id.id]])
        somme_cumul_imposable=0
        somme_ir_payes=0
        for i in payslips:
            for k in i.line_ids:
                if k.code=='C_IMP':
                    somme_cumul_imposable+=k.total
        return somme_cumul_imposable

    @api.multi
    def check_payroll(self):
        if self.employee_id:
            payrolls = self.search([['date_from','<=',self.date_from],['date_to','>=',self.date_from],'|',['date_from','<=',self.date_to],['date_to','>=',self.date_to],['employee_id','=',self.employee_id.id],['state','=','done' ]])
            if len(payrolls)>0:
                raise exceptions.Warning('Vous ne pouvez pas avoir deux bulletins validés pour un employé dans la même période!')
            else:
                xs=self.env['hr.holidays'].create({'holiday_type': 'employee','name':'Jours acquis du %s'%self.periode.name, 'number_of_days_temp': self.jours_acquis,'type':'add','employee_id':self.employee_id.id,'state':'cancel','holiday_status_id':1})
                workflow.trg_validate(self._uid, 'hr.holidays', xs.id, 'validate', self._cr)

    def get_inputs(self, cr, uid, contract_ids, date_from, date_to, context=None):
        resultat = super(HrPayslip, self).get_inputs(cr, uid, contract_ids, date_from, date_to, context=None)
        res = []
        contract_obj = self.pool.get('hr.contract')
        rule_obj = self.pool.get('hr.salary.rule')
        structure_ids = contract_obj.get_all_structures(cr, uid, contract_ids, context=context)
        rule_ids = self.pool.get('hr.payroll.structure').get_all_rules(cr, uid, structure_ids, context=context)
        sorted_rule_ids = [id for id, sequence in sorted(rule_ids, key=lambda x:x[1])]
        parent_rule_ids=sorted_rule_ids
        for id in sorted_rule_ids:
            rule=rule_obj.browse(cr, uid,id, context=context)
            if rule.parent_rule_id:
                parent_rule_ids.remove(rule.id)
        for id in parent_rule_ids:
            rule=rule_obj.browse(cr, uid,id, context=context)
            if rule.child_ids:
                for child in rule.child_ids:
                    if child.date_debut <= date_from and child.date_fin >= date_to:
                        parent_rule_ids.append(child.id)
                        parent_rule_ids.remove(rule.id)
                        break;
        for contract in contract_obj.browse(cr, uid, contract_ids, context=context):
            for rule in rule_obj.browse(cr, uid, parent_rule_ids, context=context):
                if rule.input_ids:
                    for input in rule.input_ids:
                        inputs = {
                             'name': input.name,
                             'code': input.code,
                             'contract_id': contract.id,
                        }
                        res += [inputs]
        return res

    def get_rib(self):
        rib=0
        if self.employee_id.status=="valide":
            rib=self.employee_id.rib_code_ville+''+self.employee_id.rib_code_banque+''+self.employee_id.rib_code_guichet+''+self.employee_id.rib_numero_de_banque+''+self.employee_id.cle_rib
        return rib

    def get_nbr_deduction(self):
        rules=self.details_by_salary_rule_category
        nbr_ded=0
        for r in rules:
            if r.code=='NbrPerso':
                nbr_ded=r.total
                break
        return int(nbr_ded)

    def get_nbr_enfant(self):
        nbr_enf=self.employee_id.nbre_enfants
        return int(nbr_enf)

    @api.one
    @api.depends('contract_id','periode')
    def get_salaire_journalier(self):
        salaire_de_base=0
        salaire_par_jour=0
        rubriques=self.rubriques_ids
        for rub in rubriques:
            if str(rub.name.name)=='Salaire de base':
                salaire_de_base=rub.montant
                break
        for rule in self.struct_id.rule_ids:
            if rule['code'] == 'JrTravailParMois':
                nbr_jr_de_travail_par_mois= rule['amount_fix']
                break
        salaire_par_jour = salaire_de_base/nbr_jr_de_travail_par_mois
        self.sal_journalier=salaire_par_jour

    def get_salaire_par_jour(self):
        salaire_de_base=0
        salaire_par_jour=0
        rubriques=self.rubriques_ids
        for rub in rubriques:
            if str(rub.name.name)=='Salaire de base':
                salaire_de_base=rub.montant
                break
        for rule in self.struct_id.rule_ids:
            if rule['code'] == 'JrTravailParMois':
                nbr_jr_de_travail_par_mois= rule['amount_fix']
                break
        salaire_par_jour = salaire_de_base/nbr_jr_de_travail_par_mois
        return locale.format("%.2f", salaire_par_jour, grouping=True)

    def get_cumuls_annuel(self):
            payslips_cumuls= self.env['hr.payslip'].search([['employee_id','=',self.employee_id.id]])
            cumuls={}
            for pay in payslips_cumuls:
                if datetime.strptime(pay.date_from, DEFAULT_SERVER_DATE_FORMAT).strftime("%Y")==datetime.strptime(self.date_from, DEFAULT_SERVER_DATE_FORMAT).strftime("%Y") and pay.state=='done' and datetime.strptime(pay.date_from, DEFAULT_SERVER_DATE_FORMAT).month<=datetime.strptime(self.date_from, DEFAULT_SERVER_DATE_FORMAT).month:
                    cumuls.update({datetime.strptime(pay.date_from, DEFAULT_SERVER_DATE_FORMAT).month:pay})
            cumuls.update({datetime.strptime(self.date_from, DEFAULT_SERVER_DATE_FORMAT).month:self})
            cumuls_annuel={'JrTravailParMois':0,'Net_a_payer':0,'BrutCNSSma':0,'Net_imposable':0,'Charges salariales':0,'FPRO':0,'Déd.logement':0.00,'Déd.charges familiales':0.00
                ,'cumul_BrutCNSSma':0,'cumul_Net_imposable':0,'cumul_Charges_salariales':0,'cumul_FPRO':0,'cumul_Déd.logement':0.00,'cumul_Déd.charges familiales':0.00,'cumul_jours travaillés':0}
            if not self.regul:
                for i in cumuls:
                    for line in cumuls[i].details_by_salary_rule_category:
                        if line.code==' BrutCNSSma ':
                            cumuls_annuel['cumul_BrutCNSSma']=cumuls_annuel['cumul_BrutCNSSma']+line.total
                        if line.code=='NbrPerso':
                            cumuls_annuel['cumul_Déd.charges familiales']=cumuls_annuel['cumul_Déd.charges familiales']+(line.total*30)
                        if line.code=='FPRO':
                            cumuls_annuel['cumul_FPRO']=cumuls_annuel['cumul_FPRO']+line.total
                        if line.code=='JrTravailParMois':
                            cumuls_annuel['cumul_jours travaillés']=cumuls_annuel['cumul_jours travaillés']+line.total
                        if line.code=='C_IMP':
                            cumuls_annuel['cumul_Net_imposable']=cumuls_annuel['cumul_Net_imposable']+line.total
                        if line.code=='SALC':
                            cumuls_annuel['cumul_Charges_salariales']=cumuls_annuel['cumul_Charges_salariales']+line.total

            else:
                for line in self.details_by_salary_rule_category:
                    if line.code==' BrutCNSSma ':
                        cumuls_annuel['cumul_BrutCNSSma']=cumuls_annuel['cumul_BrutCNSSma']+line.total+self.brutCNSSma
                    if line.code=='NbrPerso':
                        cumuls_annuel['cumul_Déd.charges familiales']=cumuls_annuel['cumul_Déd.charges familiales']+(line.total*30)+self.ded_cachrges_famil
                    if line.code=='FPRO':
                        cumuls_annuel['cumul_FPRO']=cumuls_annuel['cumul_FPRO']+line.total+self.cumul_FPRO
                    if line.code=='JrTravailParMois':
                        cumuls_annuel['cumul_jours travaillés']=cumuls_annuel['cumul_jours travaillés']+line.total+self.cumul_jours
                    if line.code=='C_IMP':
                        cumuls_annuel['cumul_Net_imposable']=cumuls_annuel['cumul_Net_imposable']+line.total+self.cumul_Net_imposable
                    if line.code=='SALC':
                        cumuls_annuel['cumul_Charges_salariales']=cumuls_annuel['cumul_Charges_salariales']+line.total+self.cumul_Charges_salariales

            for line in self.details_by_salary_rule_category:
                    if line.code=='NbrPerso':
                        cumuls_annuel['Déd.charges familiales']=line.total*30
                    if line.code=='JrTravailParMois':
                        cumuls_annuel['JrTravailParMois']=line.total
                    if line.code=='NET':
                        cumuls_annuel['Net_a_payer']=line.total
                    if line.code==' BrutCNSSma ':
                        cumuls_annuel['BrutCNSSma']=line.total
                    if line.code=='C_IMP':
                        cumuls_annuel['Net_imposable']=line.total
                    if line.code=='SALC':
                        cumuls_annuel['Charges salariales']=line.total
                    if line.code=='FPRO':
                        cumuls_annuel['FPRO']=line.total

            cumuls_annuel['Déd.logement']=locale.format("%.2f", cumuls_annuel['Déd.logement'], grouping=True)
            cumuls_annuel['cumul_BrutCNSSma']=locale.format("%.2f", cumuls_annuel['cumul_BrutCNSSma'], grouping=True)
            cumuls_annuel['cumul_Déd.charges familiales']=locale.format("%.2f", cumuls_annuel['cumul_Déd.charges familiales'], grouping=True)
            cumuls_annuel['cumul_FPRO']=locale.format("%.2f", cumuls_annuel['cumul_FPRO'], grouping=True)
            cumuls_annuel['cumul_jours travaillés']=locale.format("%.2f", cumuls_annuel['cumul_jours travaillés'], grouping=True)
            cumuls_annuel['cumul_Net_imposable']=locale.format("%.2f", cumuls_annuel['cumul_Net_imposable'], grouping=True)
            cumuls_annuel['cumul_Charges_salariales']=locale.format("%.2f", cumuls_annuel['cumul_Charges_salariales'], grouping=True)
            cumuls_annuel['Déd.charges familiales']=locale.format("%.2f", cumuls_annuel['Déd.charges familiales'], grouping=True)
            cumuls_annuel['JrTravailParMois']=locale.format("%.2f", cumuls_annuel['JrTravailParMois'], grouping=True)
            cumuls_annuel['Net_a_payer']=locale.format("%.2f", cumuls_annuel['Net_a_payer'], grouping=True)
            cumuls_annuel['BrutCNSSma']=locale.format("%.2f", cumuls_annuel['BrutCNSSma'], grouping=True)
            cumuls_annuel['Charges salariales']=locale.format("%.2f", cumuls_annuel['Charges salariales'], grouping=True)
            cumuls_annuel['FPRO']=locale.format("%.2f", cumuls_annuel['FPRO'], grouping=True)
            cumuls_annuel['cumul_Déd.logement']=locale.format("%.2f", cumuls_annuel['cumul_Déd.logement'], grouping=True)
            cumuls_annuel['Net_imposable']=locale.format("%.2f", cumuls_annuel['Net_imposable'], grouping=True)

            return cumuls_annuel

    @api.multi
    @api.onchange('struct_id','name','employee_id')
    def primes_variables(self):
        if self.contract_id:
            avenants=self.contract_id.avenant_ids
            rub_ids=[]

            if avenants:
                for av in avenants:
                    if av.date_start<=self.date_from and av.date_end>=self.date_to:
                        rubs_ids=av.rubrique_ids
                        for r in rubs_ids:
                            rub_ids.append((0,0,{'name':r.name.id,'montant':r.montant,'modifiable':r.modifiable}))
                        self.rubriques_ids=rub_ids
                        return self.rubriques_ids
                        break
            rub=self.env['hr.contract.rubrique'].search([['contract_id','=',self.contract_id.id]])
            for r in rub:
                rub_ids.append((0,0,{'name':r.name.id,'montant':r.montant,'modifiable':r.modifiable}))
            else:
                self.rubriques_ids=[]
                pv=self.env['hr.payslip.primes_variables'].search([['periode','=',self.periode.name]and ['matricule_emlpoyee','=',self.employee_id.matricule]])
                ap=self.struct_id.rule_ids
                ap_ap=[]
                category_prime=self.env['hr.salary.rule.category']
                for r in ap:
                    if r.category_id.code=='AP':
                        ap_ap.append(r)
                ap_ap_name=[]
                for pc in ap_ap:
                    ap_ap_name.append(pc.name)
                for pr in pv:
                    if pr.name in ap_ap_name:
                        for pp in ap_ap:
                            if pr.name==pp.name:
                                rub_ids.append((0,0,{'name':pp.id,'montant':pr.montant,'modifiable':True}))
                self.rubriques_ids=rub_ids
        return self.rubriques_ids

    def get_worked_day_lines(self, cr, uid, contract_ids, date_from, date_to, context=None):
        """
        @param contract_ids: list of contract id
        @return: returns a list of dict containing the input that should be applied for the given contract between date_from and date_to
        """

        def was_on_leave(employee_id, datetime_day, context=None):
            res = False
            day = datetime_day.strftime("%Y-%m-%d")
            holiday_ids = self.pool.get('hr.holidays').search(cr, uid, [('state','=','validate'),('employee_id','=',employee_id),('type','=','remove'),('date_from','<=',day),('date_to','>=',day)])
            if holiday_ids:
                res = self.pool.get('hr.holidays').browse(cr, uid, holiday_ids, context=context)[0].holiday_status_id.name
            return res

        res = []
        for contract in self.pool.get('hr.contract').browse(cr, uid, contract_ids, context=context):
            '''for rule in contract.struct_id.rule_ids:
                if rule.code=='' '''
            attendances = {
                 'name': _("Jours travaillés 100%"),
                 'sequence': 1,
                 'code': 'WORK100',
                 'number_of_days': 26.0,
                 'number_of_hours': 191.0,
                 'contract_id': contract.id,
            }
            leaves = {}
            day_from = datetime.strptime(date_from,"%Y-%m-%d")
            day_to = datetime.strptime(date_to,"%Y-%m-%d")
            nb_of_days = (day_to - day_from).days + 1
            for day in range(0, nb_of_days):
                #working_hours_on_day = self.pool.get('resource.calendar').working_hours_on_day(cr, uid, contract.working_hours, day_from + timedelta(days=day), context)
                #if working_hours_on_day:
                    #the employee had to work
                leave_type = was_on_leave(contract.employee_id.id, day_from + timedelta(days=day), context=context)
                if leave_type:
                    #if he was on leave, fill the leaves dict
                    if leave_type in leaves:
                        leaves[leave_type]['number_of_days'] -= 1.0
                        leaves[leave_type]['number_of_hours'] += -191/float(26)
                    else:
                        leaves[leave_type] = {
                            'name': leave_type,
                            'sequence': 5,
                            'code': leave_type,
                            'number_of_days': -1.0,
                            'number_of_hours': -191/float(26),
                            'contract_id': contract.id,
                        }
                else:
                    print 'j'
                    #add the input vals to tmp (increment if existing)
                    #attendances['number_of_days'] += 1.0
                    #attendances['number_of_hours'] += working_hours_on_day
        leaves = [value for key,value in leaves.items()]
        res += [attendances] + leaves
        return res





    def get_all_events_employee_by_contract(self):
        events=self.employee_id.event_ids
        events_in_contract=[]
        for e in events:
            if e.date_debut>=self.contract_id.date_start and e.date_fin <= self.contract_id.date_end:
                events_in_contract.append(e)
        return events_in_contract

    def get_events_impact_conge(self):
        event_impact_conge = self.get_all_events_employee_by_contract()
        for e in event_impact_conge:
            if e.impact_conge==False:
                event_impact_conge.remove(e)
        return event_impact_conge

    def get_events_impact_salaire(self):
        events_impact_salaire=[]
        event_impact_salaire = self.get_all_events_employee_by_contract() and self.get_event_du_mois()
        for e in event_impact_salaire:
            if e.impact_salaire==True:
                events_impact_salaire.append(e)
        return events_impact_salaire

    def get_event_du_mois(self):
        events=[]
        for event in self.get_all_events_employee_by_contract():
            if event.date_debut >= self.date_from:
                events.append(event)
        return events

    #à vérifier
    def get_events_maladie(self):
        events=self.get_all_events_employee_by_contract() and self.get_event_du_mois()
        events_maladie=[]
        for e in events:
            if e.event_type.name=='Maladie' and e.impact_salaire==True and e.deduire_jr_autorise==False:
                events_maladie.append(e)
        return events_maladie

    def get_events_maladie_a_deduire(self):
        events=self.get_all_events_employee_by_contract() and self.get_event_du_mois()
        events_maladie=[]
        for e in events:
            if e.event_type.name=='Maladie' and e.impact_salaire==True and e.deduire_jr_autorise==True:
                events_maladie.append(e)
        return events_maladie


    def add_event_in_rules(self):
        list_events=[]
        salaire_de_base=0
        rubriques=self.rubriques_ids
        for rub in rubriques:
            if str(rub.name.name)=='Salaire de base':
                salaire_de_base=rub.montant
                break
        nbr_jr_de_travail_par_mois = 1
        nbr_jr_maladie_autorise_par_an = 0
        for rule in self.struct_id.rule_ids:
            if rule['code'] == 'JrTravailParMois':
                nbr_jr_de_travail_par_mois= rule['amount_fix']
            elif rule['code']=='NbrJrAbsAuto':
                nbr_jr_maladie_autorise_par_an=rule['amount_fix']
        salaire_par_jour = salaire_de_base/nbr_jr_de_travail_par_mois
        category = self.env['hr.salary.rule.category'].search([('name','=','Absence/maladie')])
        somme_deduite=self.somme_jr_maladie_a_deuire()
        nbr_jr_restant = nbr_jr_maladie_autorise_par_an-somme_deduite
        somme_du_mois_a_deuire=self.somme_jour_maladie_du_mois_en_cours_a_deduire()
        somme_du_mois = self.somme_jour_maladie_du_mois_en_cours()
        if nbr_jr_restant>=0:
            nbr_jr_restant=nbr_jr_restant-somme_du_mois_a_deuire
            if nbr_jr_restant<0:
                somme_du_mois=somme_du_mois-nbr_jr_restant
                nbr_jr_restant=0
        else:
            somme_du_mois=somme_du_mois+somme_du_mois_a_deuire
        if somme_du_mois>0:
            vals={}
            vals['code'] = str(self.id)+'Maladie'
            vals['name'] = 'Maladie'
            vals['category_id'] = category.id
            vals['appears_on_payslip'] = True
            vals['sequence'] = 2
            vals['condition_select'] = 'none'
            vals['amount_select'] = 'fix'
            vals['quantity'] = somme_du_mois
            vals['amount_fix'] = locale.format("%.2f", salaire_par_jour, grouping=True)
            salary_rule = self.env['hr.salary.rule'].create(vals)
            list_events.append(salary_rule.id)
            self.env['hr.payroll.structure'].browse([self.struct_id.id]).write({'rule_ids': [(4, salary_rule.id, False)]})
        return list_events

    def somme_jr_maladie(self):
        somme=0
        events_maladie = self.get_events_maladie()
        for event in events_maladie:
            if event.date_fin<self.date_from:
                somme=somme+event.duree
        return somme

    def somme_jour_maladie_du_mois_en_cours(self):
        somme=0
        events_maladie=self.get_events_maladie()
        for event in events_maladie:
            if event.date_debut>=self.date_from and event.date_fin<=self.date_to:
                somme=somme+event.duree
        return somme

    def somme_jr_maladie_a_deuire(self):
        somme=0
        events_maladie = self.get_events_maladie_a_deduire()
        for event in events_maladie:
            if event.date_fin<self.date_from:
                somme=somme+event.duree
        return somme

    def somme_jour_maladie_du_mois_en_cours_a_deduire(self):
        somme=0
        events_maladie=self.get_events_maladie_a_deduire()
        for event in events_maladie:
            if event.date_debut>=self.date_from and event.date_fin<=self.date_to:
                somme=somme+event.duree
        return somme


class hr_payslip_primes(models.Model):

    _name = 'hr.payslip.primes'
    _inherit = 'hr.contract.rubrique'

    payslip_id = fields.Many2one('hr.payslip','primes')


class hr_payslip_run(models.Model):

    _inherit = 'hr.payslip.run'

    move_id = fields.One2many('account.move', 'lot_de_paie_id', copy=False)
    state = fields.Selection([
            ('draft', 'Draft'),
            ('close', 'Fermé'),
        ], 'Status', select=True, readonly=True, copy=False)


    def get_default_period(self):
        today = datetime.today().date()
        period =today.strftime("%m")+'/'+today.strftime("%Y")
        periods = self.env['account.period'].search([['name','=',period]])
        return periods or False
    periode = fields.Many2one('account.period','Période',default=get_default_period )

    @api.multi
    @api.onchange('periode')
    def onchange_period(self):
        if self.periode:
            self.date_start=self.periode.date_start
            self.date_end=self.periode.date_stop
        else:
            raise exceptions.Warning('veuillez choisir une période valide')

    def _get_default_journal(self):
        journals=self.env['account.journal'].search([['code','=','JPaie']])
        return journals or False

    journal_id=fields.Many2one('account.journal', 'Salary Journal', states={'draft': [('readonly', False)]}, readonly=True,default=_get_default_journal,required=True)
    @api.multi
    def comptabiliser(self):
        period_pool = self.env['account.period']
        move_pool = self.env['account.move']
        precision = self.env['decimal.precision'].precision_get('Payroll')
        timenow = time.strftime('%Y-%m-%d')
        period_id = self.periode.id
        line_ids = []
        debit_sum = 0.0
        credit_sum = 0.0
        journal_id=self.journal_id.id
        #default_partner_id = slip.employee_id.address_home_id.id
        #name = _('Payslip of %s') % (slip.employee_id.name)
        move = {
            #'narration': name,
            #'date': timenow,
            'ref': self.name,
            'journal_id': journal_id,
            'period_id': period_id,
        }
        x_mv=''
        if len(self.move_id)>0 :
            for mv in self.move_id:
                if mv.state=='draft':
                    x_mv=mv
                    break
        if x_mv:
            for lline in x_mv.line_id:
                ll_line = (0, 0, {
                        'name': lline.name,
                        'account_id': lline.account_id.id,
                        'journal_id': journal_id,
                        'period_id': period_id,
                        'debit': lline.debit,
                        'credit': lline.credit,
                        'analytic_account_id': lline.analytic_account_id,
                        'tax_code_id': False,
                        'tax_amount': 0.0,
                    })
                line_ids.append(ll_line)
        for slip in self.slip_ids:
            if slip.state=='done' and slip.comptabilise==False:
                s=self.env['hr.payslip'].browse([slip.id])
                s.write({'comptabilise':True})
                line_ids_name=[]
                for line in slip.details_by_salary_rule_category:
                    amt = slip.credit_note and -line.total or line.total
                    if float_is_zero(amt, precision_digits=precision):
                        continue
                    #partner_id = line.salary_rule_id.register_id.partner_id and line.salary_rule_id.register_id.partner_id.id or default_partner_id
                    debit_account_id = line.salary_rule_id.account_debit.id
                    credit_account_id = line.salary_rule_id.account_credit.id
                    if debit_account_id:
                        debit_line = (0, 0, {
                        'name': line.name,
                        #'date': timenow,
                        #'partner_id': (line.salary_rule_id.register_id.partner_id or line.salary_rule_id.account_debit.type in ('receivable', 'payable')) and partner_id or False,
                        'account_id': debit_account_id,
                        'journal_id': journal_id,
                        'period_id': period_id,
                        'debit': amt > 0.0 and amt or 0.0,
                        'credit': amt < 0.0 and -amt or 0.0,
                        'analytic_account_id': line.salary_rule_id.analytic_account_id and line.salary_rule_id.analytic_account_id.id or False,
                        'tax_code_id': line.salary_rule_id.account_tax_id and line.salary_rule_id.account_tax_id.id or False,
                        'tax_amount': line.salary_rule_id.account_tax_id and amt or 0.0,
                    })
                        for lin in line_ids:
                            line_ids_name.append(lin[2]['name'])
                        if debit_line[2]['name'] not in line_ids_name:
                            line_ids.append(debit_line)
                            debit_sum += debit_line[2]['debit'] - debit_line[2]['credit']
                        else:
                            for ln in line_ids:
                                if ln[2]['name']==debit_line[2]['name']:
                                    ln[2]['debit']+=debit_line[2]['debit']
                                    ln[2]['credit']+=debit_line[2]['credit']
                                    debit_sum += debit_line[2]['debit'] - debit_line[2]['credit']
                                    break

                    if credit_account_id:

                        credit_line = (0, 0, {
                        'name': line.name,
                        #'date': timenow,
                        #'partner_id': (line.salary_rule_id.register_id.partner_id or line.salary_rule_id.account_credit.type in ('receivable', 'payable')) and partner_id or False,
                        'account_id': credit_account_id,
                        'journal_id': journal_id,
                        'period_id': period_id,
                        'debit': amt < 0.0 and -amt or 0.0,
                        'credit': amt > 0.0 and amt or 0.0,
                        'analytic_account_id': line.salary_rule_id.analytic_account_id and line.salary_rule_id.analytic_account_id.id or False,
                        'tax_code_id': line.salary_rule_id.account_tax_id and line.salary_rule_id.account_tax_id.id or False,
                        'tax_amount': line.salary_rule_id.account_tax_id and amt or 0.0,
                    })
                        if credit_line[2]['name'] not in line_ids_name:
                            line_ids.append(credit_line)
                            credit_sum += credit_line[2]['credit'] - credit_line[2]['debit']
                        else:
                            for lnn in line_ids:
                                if lnn[2]['name']==credit_line[2]['name']:
                                    lnn[2]['debit']+=credit_line[2]['debit']
                                    lnn[2]['credit']+=credit_line[2]['credit']
                                    credit_sum += credit_line[2]['credit']-credit_line[2]['debit']
                                    break
        if float_compare(credit_sum, debit_sum, precision_digits=precision) == -1:
            acc_id = self.journal_id.default_credit_account_id.id
            if not acc_id:
                raise exceptions.Warning(_('Configuration Error!'),_('The Expense Journal "%s" has not properly configured the Credit Account!')%(slip.journal_id.name))
            adjust_credit = (0, 0, {
                'name': _('Adjustment Entry'),
                'date': timenow,
                'partner_id': False,
                'account_id': acc_id,
                'journal_id': journal_id,
                'period_id': period_id,
                'debit': 0.0,
                'credit': debit_sum - credit_sum,
                })
            if adjust_credit[2]['name'] not in line_ids_name:
                line_ids.append(adjust_credit)
            else:
                for li in line_ids:
                    if li[2]['name']==adjust_credit[2]['name']:
                        li[2]['credit']+=adjust_credit[2]['credit']
        elif float_compare(debit_sum, credit_sum, precision_digits=precision) == -1:
            acc_id = self.journal_id.default_debit_account_id.id
            if not acc_id:
                raise exceptions.Warning(_('Configuration Error!'),_('The Expense Journal "%s" has not properly configured the Debit Account!')%(slip.journal_id.name))
            adjust_debit = (0, 0, {
                'name': _('Adjustment Entry'),
                'date': timenow,
                'partner_id': False,
                'account_id': acc_id,
                'journal_id': journal_id,
                'period_id': period_id,
                'debit': credit_sum - debit_sum,
                'credit': 0.0,
                })
            if adjust_debit[2]['name'] not in line_ids_name:
                line_ids.append(adjust_debit)
            else:
                for li in line_ids:
                    if li[2]['name']==adjust_debit[2]['name']:
                        li[2]['debit']+=adjust_debit[2]['debit']
        if line_ids:
            move.update({'line_id': line_ids})
            move_id = move_pool.create(move)
            if x_mv:
                xx=self.env['account.move'].browse([x_mv.id])
                move_line_ids=[]
                for n in xx.line_id:
                    move_line_ids.append(n.id)
                xx.line_id.unlink()
                xx.write({'line_id':line_ids})
            else:
                self.write({'move_id': [(4, move_id.id, False)]})
            #self.move_id.append(move_id)
            #self.write({'move_id': move_id})
            if self.journal_id.entry_posted:
                move_pool.post([move_id])
        else:
            print 'aucun bP validé'
            #self.move_id=''
        #return super(hr_payslip, self).process_sheet([slip.id])

    @api.multi
    def close_payslip_run(self):
        for slip in self.slip_ids:
            if slip.state!='done':
                raise exceptions.Warning('Veuillez valider tous les bulletin de paie avant de fermer le lot')
        return self.write({'state': 'close'})

class hr_payslip_employees(models.Model):

    _inherit ='hr.payslip.employees'

    def compute_sheet(self, cr, uid, ids, context=None):
        emp_pool = self.pool.get('hr.employee')
        slip_pool = self.pool.get('hr.payslip')
        run_pool = self.pool.get('hr.payslip.run')
        slip_ids = []
        if context is None:
            context = {}
        data = self.read(cr, uid, ids, context=context)[0]
        run_data = {}
        if context and context.get('active_id', False):
            run_data = run_pool.read(cr, uid, [context['active_id']], ['date_start', 'date_end', 'credit_note','journal_id','periode'])[0]
        from_date =  run_data.get('date_start', False)
        to_date = run_data.get('date_end', False)

        journal_id = run_data.get('journal_id',False)[0]
        credit_note = run_data.get('credit_note', False)
        if not data['employee_ids']:
            raise exceptions.Warning(_("Warning!"), _("You must select employee(s) to generate payslip(s)."))
        for emp in emp_pool.browse(cr, uid, data['employee_ids'], context=context):
            slip_data = slip_pool.onchange_employee_id(cr, uid, [], from_date, to_date, emp.id, contract_id=False, context=context)
            res = {
                'employee_id': emp.id,
                'name': slip_data['value'].get('name', False),
                'struct_id': slip_data['value'].get('struct_id', False),
                'contract_id': slip_data['value'].get('contract_id', False),
                'payslip_run_id': context.get('active_id', False),
                'input_line_ids': [(0, 0, x) for x in slip_data['value'].get('input_line_ids', False)],
                'worked_days_line_ids': [(0, 0, x) for x in slip_data['value'].get('worked_days_line_ids', False)],
                'date_from': from_date,
                'date_to': to_date,
                'credit_note': credit_note,
                'journal_id':journal_id,
                'periode':run_data.get('periode',False)[0]
            }
            sl=slip_pool.create(cr, uid, res, context=context)
            sll=slip_pool.browse(cr,uid,[sl],context=context)
            sll.primes_variables()
            slip_ids.append(sl)
        slip_pool.compute_sheet(cr, uid, slip_ids, context=context)
        return {'type': 'ir.actions.act_window_close'}


    @api.model
    def emp_act(self):
        #period=self.pool.get('hr.payslip.run').read(cr, uid, [context['active_id']], ['periode'])[0]
        emp=[]
        emp_ids=self.env['hr.employee'].search([])
        payslip_run_date_start=self.env['hr.payslip.run'].browse([self._context['active_id']]).date_start
        payslip_run_date_end=self.env['hr.payslip.run'].browse([self._context['active_id']]).date_end

        for e in emp_ids:
            contracts=self.env['hr.contract'].search([['employee_id','=',e.id]])
            for c in contracts:
                if c.date_start<=payslip_run_date_start and c.date_end>=payslip_run_date_end:
                    emp.append(e.id)
                    break
        return [('id','in',emp)]
    employee_ids= fields.Many2many('hr.employee', 'hr_employee_group_rel', 'payslip_id', 'employee_id', 'Employees',domain=emp_act)


class Account_move(models.Model):
    _inherit = 'account.move'

    lot_de_paie_id=fields.Many2one('hr.payslip.run','move_ids')


class PrimesVariables(models.Model):
    _name='hr.payslip.primes_variables'

    name=fields.Char('nom',translate=True)
    periode=fields.Char('Période')
    matricule_emlpoyee=fields.Char('Matricule')
    montant=fields.Float('Montant')

    @api.model
    def create(self,vals):
        emp= self.env['hr.employee'].search([['matricule','=',vals['matricule_emlpoyee']]])
        rules=emp.categorie_id.structure_id.rule_ids
        rules_name=[]
        for r in rules:
            rules_name.append(r.name)
        if vals['name'] in rules_name:
            s=super(PrimesVariables,self).create(vals)
            return s
        else:
            return False

